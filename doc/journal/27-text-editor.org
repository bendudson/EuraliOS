* A text editor for EuraliOS

EuraliOS really needs a simple text editor, to be able to start
doing useful things like changing the configuration from within
the operating system itself.

Ultimately it would probably be best to support a library like
[[https://github.com/crossterm-rs/crossterm][Crossterm]] or [[https://github.com/redox-os/termion][Termion]]  (used in Redox OS), that many programs
can use to provide a terminal interface. For now we'll write a
simple editor, as an excuse to learn something about text editor
data structures.

The first thing our text editor needs is a way to read command line
arguments. Well, maybe not the first thing, but it's what seemed
achievable.

* Command line arguments

Command-line arguments in Rust are collected by calling
=std::env::args()= (see the [[https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html][Rust book]]). In EuraliOS the interface
will be:

#+begin_src rust
  use euralios_std::env;
  ...
  let args: Vec<String> = env::args().collect();
#+end_src

To make this work the command-line arguments must be passed
from the parent to the new process. One way would be to send a
message from the parent to the child process, containing the
arguments. This would add more syscalls to the process startup,
and create possible deadlocks for the parent process if the
child didn't start correctly. Instead we can use the parameter
string that is already passed to the =exec= syscall.

In [[25-multiple-users.org][Multiple Users]] the parameter string was used to specify the Virtual
File System (VFS) of the child process. This uses a simple format with
single character commands (e.g. 'C' copies the parent VFS, '-' removes
a mount path). We now add another command 'A' that specifies a
null-terminated string.

The library interface to =exec= is =euralios_std::syscalls::exec=.  We
add an =args: Vec<&str>= input, push an 'A' character to the parameter
string followed by these strings separated by =0x03=, the =ETX=
End-of-text ASCII control character, and terminating with a =0= byte.

In the kernel =sys_exec= function the argument string is copied into a
=Vec<u8>= on the kernel heap so that it's accessible when the page
table is changed. It's then passed as a new input to
=new_user_thread= in =process.rs=.

The argument string is passed to the new process on the stack:
Stacks grow downwards, to the string is put on the stack above
the length of string. Then register =rdx= is set to the address
of the string length. In the =_start= function (that calls the
user =main()=) we get =args_address= from =rdx= and then store
the =u8= slice in a =static mut= variable:

#+begin_src rust
  ARGS_SLICE = unsafe{
      let length = *(args_address as *mut i32) as usize;
      slice::from_raw_parts((args_address + 4) as *const u8, length)
  };
#+end_src

Once a program starts, this slice is only read by calling an
internal function =get_args -> &'static [u8]=.
The user accesses this through the =env::args()= function:

#+begin_src rust
  pub fn args() -> impl Iterator<Item = String> {
    // Convert bytes into a vector of owned strings
    get_args()
        .split(|&b| b == 0x03)
        .map(|arg| String::from_utf8_lossy(arg).into_owned())
  }
#+end_src

This splits the string on =0x03= chars, as used in the
=euralios_std::syscalls::exec= function. We can now start
an editor and get the command-line arguments:

#+begin_src rust
  use euralios_std::{println, env};

  #[no_mangle]
  fn main() {
      for arg in env::args() {
          println!("Arg: {}", arg);
      }
  }
#+end_src

* Text editor piece table

Now we can tell the editor which file to open, we need to choose how
to represent the data in memory. Here we're going to implement a [[https://en.wikipedia.org/wiki/Piece_table][Piece
table]], one of several data structures used in text editors (others
include [[https://en.wikipedia.org/wiki/Gap_buffer][Gap buffers]] and [[https://en.wikipedia.org/wiki/Rope_(data_structure)][Ropes]]. For small files a simple =Vec= is
probably sufficient).

Piece tables have three components: The original text, that is read
and never modified, an "Add buffer" that is added to (never removed)
as the user types, and the piece table itself. The piece table
describes the order of pieces of text in the document. Each piece can
come from either the Original buffer or the Add buffer, and has a
starting position in that buffer and a length.  When a file is first
opened there is only one piece, the whole of the Original buffer. As
text is added or deleted, more pieces are created. When the text is
displayed on screen or saved to file, the pieces are assembled in the
order in the piece table.

We can define a Piece as:
#+begin_src rust
  #[derive(Clone, Copy)]
  enum Piece {
      // Start, len [bytes]
      Original{start: usize, len: usize},
      Add{start: usize, len: usize},
  }
#+end_src

* Adding a status bar



* Moving around the file

Basic text editing is now working, but we can't move around by
going up and down lines or edit files longer than a single
screen.
