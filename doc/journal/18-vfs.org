* Virtual File System

In [[./13-return-to-sender.org][section 13]] we implemented a very basic Virtual File System (VFS),
which has allowed programs to open particular paths e.g "/dev/nic" to
get a communication handle.

Opening "/tcp/192.80.49.99/70" should result in the tcp server opening
a new socket, connecting to the given address (192.80.49.99,
gopher.floodgap.com) and port (70). The returned communication handle
should allow sending (writing) and receiving (reading) data through
that socket.

1. The client calls the =open= syscall with the "/tcp/192.80.49.99/70" string
2. The kernel checks the client's VFS, choosing the mount point which
   matches the longest part of the string, in this case "/tcp".
2. The kernel sends an =OPEN= message to the rendezvous at that mount
   point, passing the rest of the string, e.g. "142.250.188.4:80".
3. The =tcp= process receives the =OPEN= message, returning a new
   handle for this connection. Inside the =tcp= process a new thread
   might be spawned to service the new connection.
4. The kernel returns the new handle to the client

At some point we'll have to add permissions to this mechanism, to
prevent users from modifying each others' files or messing up the
system. In EuraliOS this will be mainly capabilities based: A process
can only access a resource if it has a communication handle to it, and
each process can be given its own separate VFS with only the resources
it's allowed to access. The =open= syscall (and =OPEN= message) should
have permissions flag, so the ways that the communication handle is
used can be restricted.


