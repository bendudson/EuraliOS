* Syscalls for thread control

Now we're going to add system calls to enable user threads to create
new threads, and exit cleanly. We'll learn about the [[https://www.felixcloutier.com/x86/swapgs][swapgs]] and [[https://www.felixcloutier.com/x86/wrmsr][wrmsr]]
instructions.

** Switching stack on Syscall

   Syscall handlers have a problem because they need to preserve all
registers, while switching to a kernel stack and saving the user stack
pointer somewhere. Reasons to avoid using the user stack include:
1. Avoiding a stack overflow while in ring 0, which could overwrite
   anything or just lead to a page fault while in kernel space.
   Instead we switch to a known good stack location.
2. Not leaving kernel data on the user stack, potentially leaking
   information which a malicious program could use.

A common solution is to use the GS segment register. In 64-bit mode this
register contains a 64-bit address, and memory can be accessed as an offset
from this address. For example
#+begin_src nasm
mov gs:0x24, rsp
#+end_src
copies the stack pointer (RSP) to a virtual memory address calculated
by taking the value in GS and adding =0x24=. If we can set the value
of GS, then we can use it to save the user stack pointer to a memory
address and retrieve a kernel stack pointer.

There are two ways to access the GS and FS 64-bit registers directly:
1. The [[https://www.felixcloutier.com/x86/wrmsr][wrmsr]] instruction writes to Model Specific Registers, and was
   used in [[file:02-userspace.org][an earlier section]] to set up syscalls. It can only be
   executed in ring 0. According to the [[https://www.amd.com/system/files/TechDocs/24593.pdf][AMD documentation]] the FS base
   address is MSR =0xC000_0100= and the GS base address is
   =0xC000_0101=.

2. The wrfsbase and wrgsbase instructions write to the FS and GS base
   registers, and can be executed in any privilege level. These need
   to be enabled by setting a bit in the CR4 control register. There
   is an [[https://lwn.net/Articles/821723/][LWN article on enabling FSGSBASE in Linux]].

Note that push, pop and mov only access the lower 32 bits of the GS
and FS registers.

There is a third way to set the GS register indirectly, which allows
the kernel to store an address in a location that is hidden from user
programs. This Kernel GS base address is MSR =0xC0000102=. The
=swapgs= instruction swaps the values in the user and kernel GS base
registers. What we can do is:

1. Store a memory address in the kernel GS base register
2. Allow users to modify the GS register
3. On entering the syscall handler, execute =swapgs= to swap the user and kernel
   GS values
4. Use GS to access memory, saving the user stack pointer and loading
   a kernel stack pointer.
5. Before going back to user code swap the GS registers back

As discussed in [[https://wiki.osdev.org/SWAPGS][this OSdev page]] a common strategy is to swap the GS
registers on every transition between user and kernel code, at the
start and end of syscalls and interrupt handlers.  That page notes
that there are some problems with this approach: If an interrupt is
allowed to occur during a syscall, while the GS registers are swapped,
then they will be swapped again! To handle this there are ways to
detect whether the interrupt occurred while in kernel code.

The approach we'll use here is to avoid this problem by only using
=swapgs= in the syscall handler, keeping the user GS register loaded
in the rest of the kernel code.

*** Setting kernel GS base

A good choice for the kernel GS base register is to point to the [[https://wiki.osdev.org/Task_State_Segment][Task
State Segment]] (TSS) table. This table is different for each CPU core,
so will still work if (when?) we support multiple cores, and we
already store kernel stack pointers in the TSS for use in the timer
interrupt context switch. The [[https://github.com/redox-os/kernel/blob/master/src/arch/x86_64/interrupt/syscall.rs#L65][Redox OS]] syscall handler does something
like this.

We need a function to get the address of the TSS. In =gdt.rs= add
a function
#+begin_src rust
  pub fn tss_address() -> u64 {
      let tss_ptr = &*TSS.lock() as *const TaskStateSegment;
      tss_ptr as u64
  }
#+end_src
then in =syscalls.rs= we define the MSR number:
#+begin_src rust
const MSR_KERNEL_GS_BASE: usize = 0xC0000102;
#+end_src
and then the =init= function can put the TSS address in
the kernel GS base register:
#+begin_src rust
  asm!(
      // Want to move RDX into MSR but wrmsr takes EDX:EAX i.e. EDX
      // goes to high 32 bits of MSR, and EAX goes to low order bits
      // https://www.felixcloutier.com/x86/wrmsr
      "mov eax, edx",
      "shr rdx, 32", // Shift high bits into EDX
      "wrmsr",
      in("rcx") MSR_KERNEL_GS_BASE,
      in("rdx") gdt::tss_address()
  );
#+end_src
This puts the TSS address in RDX and writes it to the MSR. It looks
more complicated than it is because [[https://www.felixcloutier.com/x86/wrmsr][wrmsr]] uses two 32-bit registers to
set the 64-bit address: The low 32 bits of the address are moved to EAX,
and then the high 32 bits in RDX are shifted down to the 32 bits in EDX.
=wrmsr= takes these two pieces and puts them back together in the MSR.

** Using SWAPGS in syscall handler

When the syscall handler starts, we want to save the user RSP, and
load a kernel stack pointer. The kernel stack pointer for the current
process is stored in the TSS, entry number =gdt::TIMER_INTERRUPT_INDEX=
which is currently set to 1. There are 7 available interrupt stack entries,
so we can use one of them to temporarily store the user stack pointer.
In =gdt.rs= we'll define a constant:
#+begin_src rust
pub const SYSCALL_TEMP_INDEX: u16 = 2;
#+end_src
which we can use in =syscalls.rs= at the start of the =handle_syscall=
function:
#+begin_src rust
  asm!("swapgs",
       "mov gs:{tss_temp}, rsp", // save user RSP
       "mov rsp, gs:{tss_timer}" // load kernel RSP
       ...
       tss_timer = const(0x24 + gdt::TIMER_INTERRUPT_INDEX * 8),
       tss_temp = const(0x24 + gdt::SYSCALL_TEMP_INDEX * 8),
#+end_src
The offset of the interrupt stack index (0x24) is determined from the
[[https://wiki.osdev.org/Task_State_Segment][Task State Segment]] layout.

This kernel stack is also used by the timer interrupt for context switches.
If we want to allow context switches while handling a syscall, then
we need to make sure that syscalls use a different part of the kernel stack.
The kernel stack is two pages (8k) so we can move the pointer by an offset
and have enough space:
#+begin_src rust
  const SYSCALL_KERNEL_STACK_OFFSET: u64 = 1024;
#+end_src
which is applied to rsp:
#+begin_src rust
  asm!(...
       "sub rsp, {ks_offset}",
       ...
       ks_offset = const(SYSCALL_KERNEL_STACK_OFFSET));
#+end_src

We can now save the user stack pointer onto the kernel stack,
and swap the GS registers back:
#+begin_src rust
  asm!(...
       "push gs:{tss_temp}", // user RSP
       "swapgs"
       ...
       ks_offset = const(SYSCALL_KERNEL_STACK_OFFSET));
#+end_src



** Create Context struct in syscall

When a thread fork syscall is made, a new thread context must be made
that is the same as the original thread, and can be put in the
scheduler. The easiest way to do this is to capture a Context in
syscall in the same way that we do in a timer interrupt.




** Kernel code to fork threads


** User code to spawn new threads


** Exiting threads



** User panic handler

We can use these syscalls to write a better panic handler in the user program
=hello.rs=:
#+begin_src rust
  #[panic_handler]
  fn panic(info: &PanicInfo) -> ! {
      println!("User panic: {}", info);
      unsafe {
          asm!("mov rax, 1", // exit_current_thread syscall
               "syscall");
      }
      loop {}
  }
#+end_src
So now when a user thread panics it will print the error message and exit.

** Appendix: Security issues

Security issues: https://fuchsia.dev/fuchsia-src/concepts/kernel/sysret_problem


** Appendix: Syscall jump table

This is an alternative approach which I don't think is optimal, but is
here in case it's helpful.

In C we can create a static array of function pointers (addresses), so
that functions can be called when indexing into this array. This is used
in Linux (for example) to enable fast lookup of a function pointer from
a syscall number.

In rust this seems to be difficult: Function pointers aren't known at
compile time (only link time), and so attempting to cast a function to
a =u64= statically doesn't compile. The usual trick of using
=lazy_static= also doesn't work because we need to know the address of
the array at link time.

The closest I've found so far is to define a static mutable array
(highly discouraged!) in =syscalls.rs=:
#+begin_src rust
  const SYSCALL_NUMBER: usize = 2;
  static mut SYSCALL_HANDLERS : [u64; SYSCALL_NUMBER]
    = [0; SYSCALL_NUMBER];
#+end_src

In the =init()= function we can populate this array:
#+begin_src rust
  unsafe {
      SYSCALL_HANDLERS = [
          sys_read as u64,
          sys_write as u64
      ];
  }
#+end_src

Now the syscall handler code can be simplified: It first
checks that the syscall number (in =rax=) is in range, and if so
looks up the handler address in the =SYSCALL_HANDLERS= table:
#+begin_src rust
  asm!(
      ...,
      "push r15",

      "cmp rax, {syscall_max}",
      "jge 1f",  // Out of range
      "mov rax, [{syscall_handlers} + 8*rax]", // Lookup handler address
      "call rax",
      "1: ",

      "pop r15",
      ...,
      syscall_handlers = sym SYSCALL_HANDLERS,
      syscall_max = const SYSCALL_NUMBER,
      options(noreturn)
  );
#+end_src
To be able to use the =const= argument to =asm= we need to add
this feature to the top of =lib.rs= with =#![feature(asm_const)]=.
