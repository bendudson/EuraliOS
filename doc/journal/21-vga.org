* VGA driver and terminals

The time has come to improve the text output, so that we can do more
complicated things with text, and have multiple processes writing text
output without interfering with each other like =rtl8139= and =gopher=
in the [[./20-dns.org][last section]].

The terminal consists of both input and output: when a user is
interacting with a program the keyboard & mouse input should go to
that program, and anything the program outputs should be shown on
screen. We therefore need some kind of multiplexer which will take one
console (combination of input & output) and split it into multiple
[[https://en.wikipedia.org/wiki/Virtual_console][virtual consoles]].

A sketch of how this might work is shown below:
#+begin_src
        <vga>   <keyboard/mouse>
          |            |
           < vconsole >
                |
      ------------------------
      |       |       |
    debug   login1  login2 ...
              |
            shell
#+end_src
The =vga= program should provide an interface for writing text to
screen, but only needs to handle one screen. The =vconsole=
multiplexer will catch keys like =Ctrl + F1=, =Ctrl + F2= and switch
the input & output between multiple sets of input/output pairs: One
could be a debug/status screen, and others connected to instances of a
=login= program. That program will be responsible for restricting user
capabilities, mainly by customising the Virtual File System (VFS) that
the user sees. When a user logs in a shell would be connected, which
might have further multiplexing for =Ctrl + Tab= switching between
processes, or for arranging multiple programs on screen at once.

To enable all this to happen we need a way to specify where on the
screen text should be drawn, what color it should be, whether it
blinks etc. Fortunately there is an ANSI standard for doing this.

** VGA device driver

We probably need a very basic VGA driver in the kernel, at least for
now, as a fallback and for debugging any startup issues. The choice
then is between making that kernel driver more complete, or creating a
new VGA driver which runs in user space. In the long run something
like [[https://wiki.osdev.org/GOP][UEFI GOP]] is probably the way to go for high-resolution graphics,
so extended VGA support will become optional rather than baked into
the kernel. I'd like to keep the kernel as minimal as possible, so this
will be a user-space driver.

There is a Rust [[https://crates.io/crates/vga][vga crate]] which is [[https://github.com/rust-osdev/vga][hosted on github]] and includes both
text (up to 80x25) and graphics modes (up to 640x480x16). It
depends on some other crates, including [[https://crates.io/crates/font8x8][font8x8]] which provides
8x8 pixel unicode characters.

VGA (and all other graphics drivers that I know of) depend heavily on
Direct Memory Access (DMA): the CPU writes to memory addresses, which
are mapped into registers on the graphics card.

** Accessing video memory

The =vga= library expects to find the VGA buffer at the virtual
address identity mapped to the physical address i.e. the range
=0xA0000 ..= 0xBFFFF= (inclusive). We could add a special case, and
map these pages into the user program. It would be better though if we
could make this a memory chunk which could be passed between
processes: The kernel might pass this to an =init= user program, which
then might choose which driver to load and pass the memory chunk
to. That means we need to modify the =vga= library so the vga memory
can start at an arbitrary virtual address.


** Running the VGA program from Init

#+begin_src rust
  // Start the VGA driver
  syscalls::exec(
      include_bytes!("../../user/vga_driver"),
      syscalls::EXEC_PERM_IO, // I/O permissions
      vga_com2.clone(),
      vga_com2);
#+end_src

#+begin_src rust
  // Assemble a slice then copy to a Vec in the kernel heap
  let bin_vec = unsafe{slice::from_raw_parts(bin, bin_length as usize)}.to_vec();
#+end_src

When this tries to allocate memory for the `vga_program` ELF binary
the allocation fails, shown in figure [[fig-kernel-panic]].

#+CAPTION: Kernel panic when allocating memory
#+NAME: fig-kernel-panic
[[./img/21-01-kernel-panic.png]]

This is because the kernel heap is only 100kb, so part of the
solution is to just increase the kernel heap size. It would be good to avoid
a kernel panic by first checking if memory can be allocated:
#+begin_src rust
  // Assemble a slice pointing to user data
  let bin_slice = unsafe{slice::from_raw_parts(bin, bin_length as usize)};

  let mut bin_vec : Vec<u8> = Vec::new();
  // Reserve space
  if bin_vec.try_reserve_exact(bin_slice.len()).is_err() {
      // Could not allocate memory
      println!("[kernel] Couldn't allocate {} bytes for Exec from thread {}", bin_slice.len(), thread.tid());
      thread.return_error(SYSCALL_ERROR_MEMORY);
      process::set_current_thread(thread);
      return;
  }
  // Copy data into vector, which is now large enough
  bin_vec.extend(bin_slice.iter());
#+end_src

Now we get the slightly more useful result in figure [[fig-user-panic]]:
The kernel can't allocate enough memory, so returns with an error
message; the user program (=init=) panics but other programs (=pci=)
continue.
#+CAPTION: User panic when allocating memory
#+NAME: fig-user-panic
[[./img/21-02-user-panic.png]]



#+CAPTION: Starting TCP stack with output to VGA driver
#+NAME: fig-writer-sys
[[./img/21-03-writer-sys.png]]


** ANSI escape codes

[[https://en.wikipedia.org/wiki/ANSI_escape_code][ANSI escape codes]] are used to change the position and color
of the cursor on text-based terminals.

https://github.com/rust-osdev/ansi_rgb
