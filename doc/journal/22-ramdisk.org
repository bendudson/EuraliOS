* Creating a RAMdisk

One of the most important functions of an operating system
is keeping track of users' important (and not so important)
data, and providing ways to access and modify it. Usually
this is done by organising data into files in a hierarchical
directory structure. We've made a start on a Virtual File System
(VFS) with OPEN, READ and WRITE messages, but not used them
for actual files yet. To make sure that the system we end up with
isn't tied to a specific filesystem we're first going to get
something working with data stored in memory. Later we'll need
to worry about block storage devices and all that.

** Single directory

To start with we can simplify things by only having a single
directory.


** Basic shell

#+CAPTION: Starting the EuraliOS shell!
#+NAME: fig-welcome
[[./img/22-01-welcome.png]]

#+begin_src rust
  fn exec_path(path: &str) -> Result<(), SyscallError> {
      let mut file = File::open(&path)?;

      let mut bin: Vec<u8> = Vec::new();
      file.read_to_end(&mut bin)?;

      // Create a communication handle for the input
      let (exe_input, exe_input2) = syscalls::new_rendezvous()?;

      syscalls::exec(
          &bin,
          0, // Permission flags
          exe_input2,
          syscalls::STDOUT.clone());

      loop {
          // Wait for keyboard input
          match syscalls::receive(&syscalls::STDIN) {
              Ok(syscalls::Message::Short(
                  message::CHAR, ch, _)) => {
                  // Received a character
                  syscalls::send(&exe_input,
                                 syscalls::Message::Short(
                                     message::CHAR, ch, 0));
              },
              _ => {
                  // Ignore
              }
          }
      }

      Ok(())
  }
#+end_src

Now we can run a program (well one program, gopher) but when it exits
the shell will be suspended waiting to either send a message to the
program or to receive a keyboard input.

When receiving messages we could have a timeout, and when sending
messages we need some way to detect whether the process is still
running. One way would be to detect if the communication handle had
been dropped: If we try to communicate with a Rendezvous with only one
handle, or drop a handle with a waiting thread then we could return an
error message.

** Discovering files and other things

At the moment the ramdisk can store and retrieve files, but there's no
way to find out what files are present. To provide a basic =ls=
command we'll need to at least be able to list files (and
directories). I'd like to make the system discoverable, by enabling
any handle can be queried to find out what it is, what messages it can
respond to, what inputs it expects etc.

Adding a =QUERY= message type, which will be responded to with a =JSON=
message (in =euralios_std/src/message.rs=):
#+begin_src rust
pub const QUERY: u64 = 7;
pub const JSON: u64 = 8;
#+end_src
JSON may not be the best choice but it's a) human readable for
debugging and manipulation, and b) widely supported, in particular by
the Rust [[https://serde.rs/][serde]] [[https://github.com/serde-rs/json][library]] in no-std environments. Other serialisation
formats are available.

In =ramdisk/src/main.rs= in the =handle_directory()= function we can
add a match for =QUERY= tagged messages, assemble a JSON string (by
hand, for now), returning by copying the string into
a memory chunk and sending it back in a message tagged =JSON=.

In the =shell= program, entering "ls" opens =/ramdisk= and
queries it:
#+begin_src rust
  let mut line_buffer = String::new();
    loop {
        // prompt
        print!("$ ");

        // Read a line of input
        stdin.read_line(&mut line_buffer);
        let input = line_buffer.trim();

        if input == "ls" {
            if let Ok(file) = File::open("/ramdisk") {
                file.query()
            }
        }
        ...
#+end_src

The =query= method is a EuraliOS-specific extension to =fs::File=.
It sends a =QUERY= message and for now just prints whatever comes back.
In =euralios_std/src/fs.rs=:
#+begin_src rust
  impl File {
    ...
    pub fn query(&self)  {
        match rcall(&self.0,
                    message::QUERY,
                    0.into(), 0.into(), None) {
            Ok((message::JSON,
                MessageData::Value(length),
                MessageData::MemoryHandle(handle))) => {

                let u8_slice = handle.as_slice::<u8>(length as usize);
                if let Ok(s) = str::from_utf8(u8_slice) {
                    println!("[query]: {}", s);
                }
            },
            message => {
                println!("[query] received {:?}", message);
            }
        }
    }
  }
#+end_src
The result is in figure [[fig-ls]]

#+CAPTION: Querying a RAMdisk directory
#+NAME: fig-ls
[[./img/22-02-ls.png]]
