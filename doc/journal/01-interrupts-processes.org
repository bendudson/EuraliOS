* Interrupts and processes

This begins after [[https://os.phil-opp.com/heap-allocation/][Phil-Opp's excellent post on heap allocation]]: We
have a kernel with basic terminal and keyboard I/O, and kernel memory
allocation from a fixed size heap.

** Accessing processor context

The x86-interrupt calling convention saves scratch registers, and passes a pointer
to the exception stack frame to the handler function. It was introduced in
[[https://github.com/rust-lang/rust/pull/39832][this PR]] which has some useful comparisons and links. 

In =interrupts.rs= :
#+BEGIN_SRC rust
#[derive(Debug)]
#[repr(packed)]
pub struct Context {
    // These are pushed in the handler function
    fs: usize,
    r11: usize,
    r10: usize,
    r9: usize,
    r8: usize,
    rsi: usize,
    rdi: usize,
    rdx: usize,
    rcx: usize,
    rax: usize,
    // Below is the exception stack frame pushed by the CPU on interrupt
    // Note: For some interrupts (e.g. Page fault), an error code is pushed here
    rip: usize,     // Instruction pointer
    cs: usize,      // Code segment
    rflags: usize,  // Processor flags
    rsp: usize,     // Stack pointer
    ss: usize,      // Stack segment
    // Here the CPU may push values to align the stack on a 16-byte boundary (for SSE)
}
#+END_SRC

We now define a function

#+BEGIN_SRC rust
#[naked]
pub extern "x86-interrupt" fn timer_handler_naked (
   _stack_frame: InterruptStackFrame) {
  unsafe {
  ...
  }
}
#+END_SRC
Here the =x86-interrupt= calling convention is specified to satisfy
the requirements of the IDT =set_handler_fn= method, but doesn't have
any effect because the function is =[naked]=.

Because naked functions are still somewhat experimental, we
need to enable this feature in =lib.rs=:
#+BEGIN_SRC rust
#![feature(naked_functions)]
#+END_SRC

While we're editing =lib.rs=, add another feature we'll need soon:
#+BEGIN_SRC rust
#![feature(asm_sym)]
#+END_SRC
which enables the =sym= operands in assembly blocks, used to take
the address of symbols.

Now we can fill in the =unsafe= block in the =timer_handler_naked=
function. In =interrupts.rs= import the =asm!= macro:
#+BEGIN_SRC rust
use core::arch::asm;
#+END_SRC
and then create an =asm!= block inside the unsafe scope of
=timer_handler_naked=:
#+BEGIN_SRC rust
  asm!(
      // Disable interrupts
      "cli",
      // Push registers
      "push rax
       push rcx
       push rdx
       push rdi
       push rsi
       push r8
       push r9
       push r10
       push r11
       push fs",

      // First argument in rdi with C calling convention
      "mov rdi, rsp",
      // Call the hander function. Note that this might switch stack.
      "call {handler}",

      // Pop scratch registers
      "pop fs
       pop r11
       pop r10
       pop r9
       pop r8
       pop rsi
       pop rdi
       pop rdx
       pop rcx
       pop rax",
      // Enable interrupts
      "sti",
      // Interrupt return
      "iretq",
      // Note: Getting the handler pointer here using `sym` operand, because
      // an `in` operand would clobber a register that we need to save, and we
      // can't have two asm blocks
      handler = sym timer_handler,
      options(noreturn)
  );
#+END_SRC

The final part is to create the actual handler which will be
called:
#+BEGIN_SRC rust
extern "C" fn timer_handler(context: &mut Context) {
    print!("+");

    // Tell the PIC that the interrupt has been processed
    unsafe {
        PICS.lock()
            .notify_end_of_interrupt(InterruptIndex::Timer.as_u8());
    }
}
#+END_SRC
Note that the C calling convention here means some registers will
be pushed onto the stack again.
We then set the IDT entry to the new handler:
#+BEGIN_SRC rust
idt[InterruptIndex::Timer.as_usize()]
            .set_handler_fn(timer_handler_naked); // new
#+END_SRC

*** Testing

First check that this compiles and runs (=cargo run=). We can
then check that the values of the registers are saved and
restored correctly. In the new =timer_handler= function we can
print some registers, change change them, and then checking
that the change is seen in the interrupted code.

In =main.rs=, before the =hlt_loop()= call we can try this:
#+BEGIN_SRC rust
  // Set some registers
  unsafe {
    asm!("mov r11, 0x4242",
         "mov rdi, 0x22",
         "mov rcx, 0x93"
    );
  }

  // Wait for an interrupt
  unsafe {asm!("hlt");}

  // Get the register values
  let (r11, rdi, rcx): (i64, i64, i64);
  unsafe {asm!("nop",
               lateout("r11") r11,
               lateout("rdi") rdi,
               lateout("rcx") rcx);}
  println!("R11: 0x{:x} RDI: 0x{:x} RCX: 0x{:x}", r11, rdi, rcx);
#+END_SRC
which will need the =asm!= macro so put =use core::arch::asm;= near
the top of =main.rs=. When this runs we should see
=R11: 0x4242 RDI: 0x22 RCX: 0x93=, so the registers weren't modified by
the interrupt.

Now in =interrupt.rs= we can access and modify some registers, and check
that they are set correctly:
#+BEGIN_SRC rust
extern "C" fn timer_handler(context: &mut Context) {
    print!("<0x{:x}, 0x{:x}>", context.r11, context.rcx);
    context.r11 = context.rdi + 0x5321;
    context.rcx = 0xdeadbeef;

    // Tell the PIC that the interrupt has been processed
    unsafe {
        PICS.lock()
            .notify_end_of_interrupt(InterruptIndex::Timer.as_u8());
    }
}
#+END_SRC
So we now print the values of some registers, and modify the =r11= and =rcx=
registers. Running again we should see:
#+BEGIN_SRC
<0x4242, 0x93> R11: 0x5343 RDI: 0x22 RCX: 0xDEADBEEF
It did not crash!
<0x5343, 0xDEADBEEF><0x5343, 0xDEADBEEF>...
#+END_SRC
This shows that the timer handler can read and modify the process state,
which we'll need when we want to switch processes.

*** Test case

To turn this into a test case we can keep around, we need some way to test the
wrapper code while replacing the =timer_handler=.
Based on the [[https://github.com/vinc/moros/blob/trunk/src/sys/idt.rs#L123][MOROS]] code, turn the =timer_handler_naked= function into a macro:

#+BEGIN_SRC rust
  macro_rules! wrap {
      ($func: ident => $wrapper:ident) => {
          #[naked]
          pub extern "x86-interrupt" fn $wrapper (_stack_frame: InterruptStackFrame) {
              unsafe{
                ...
              }
          }
      };
  }
#+END_SRC
which can create the hander as before:
#+BEGIN_SRC rust
wrap!(timer_handler => timer_handler_naked);
#+END_SRC
Running (=cargo run=) should give the same result as before, but now we can
write tests for the macro by wrapping different functions.

We can make a standalone test like the =stack_overflow= test by making the =Context= struct
members public, exporting the =wrap= function (renamed to =interrupt_wrap=), and setting up a minimal
IDT in the test case. This is in =tests/interrupt_wrap.rs=.

** Kernel task switching

Pre-emptive multitasking with kernel threads, using the timer
interrupt to switch between threads.

There is a lot of confusing information online about interrupt
handling in x86.  Most of this confusion is due to the different
behaviour which has evolved over the last 40-some years: Real mode,
32-bit protected mode and 64-bit mode all work somewhat differently.
For 64-bit mode there is a good summary [[https://os.phil-opp.com/cpu-exceptions/][here]]. 

There is sometimes a distinction between interrupts which result in a
change in privilege level (interrupt occurs when running user code in
ring 3), and interrupts which don't (interrupt occurs while running
kernel code).

In 64-bit mode interrupts can switch to known-good stacks which are
listed in the Interrupt Stack Table (IST), which has 7 entries. The
index into this table which should be used is specified in the
Interrupt Descriptor Table (IDT).
** Loading executables

The standard executable format on Unix-like operating systems is ELF.

This follows closely what MOROS does. We use the [[https://crates.io/crates/object][object]] crate to parse
the ELF format
#+BEGIN_SRC
object = { version = "0.27.1", default-features = false, features = ["read"] }
#+END_SRC
then in =process.rs=
#+BEGIN_SRC rust
use object::{Object, ObjectSegment};
#+END_SRC

To create a simple executable, create a file =src/bin/hello.rs=
#+BEGIN_SRC rust
#![no_std]
#![no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

#[no_mangle]
pub unsafe extern "sysv64" fn _start() -> ! {
    loop {}
}
#+END_SRC

then compile with
#+BEGIN_SRC
$ cargo build
#+END_SRC
which should create an executable =target/x86_64-blog_os/debug/hello=

#+BEGIN_SRC rust
  pub fn new_user_thread(bin: &[u8]) -> Result<usize, &'static str> {
      // Check the header
      const ELF_MAGIC: [u8; 4] = [0x7f, b'E', b'L', b'F'];

      if bin[0..4] != ELF_MAGIC {
          return Err("Expected ELF binary");
      }
      // Use the object crate to parse the ELF file
      // https://crates.io/crates/object
      if let Ok(obj) = object::File::parse(bin) {
          let entry_point = obj.entry();
          println!("Entry point: {:#016X}", entry_point);

          for segment in obj.segments() {
              println!("Section {:?} : {:#016X}", segment.name(), segment.address());
          }
      } else {
          return Err("Could not parse ELF");
      }
      Ok(0)
  }
#+END_SRC

In =main.rs= we now include the =hello= executable using the
[[https://doc.rust-lang.org/std/macro.include_bytes.html][include_bytes]] macro:
#+BEGIN_SRC rust
process::new_user_thread(include_bytes!("../target/x86_64-blog_os/debug/hello"));
#+END_SRC

Running this with
#+BEGIN_SRC
$ cargo run --bin blog_os
#+END_SRC
should produce a result like

#+BEGIN_SRC
Entry point: 0x00000000201120
Section Ok(None) : 0x00000000200000
Section Ok(None) : 0x00000000201120
#+END_SRC

Unfortunately this entry point virtual memory address is in the same
range as the kernel. To handle this we can try to use separate page
tables for kernel and users, but this means frequently switching page
tables (and flushing the TLB). In addition interrupt handlers must be
mapped in the user virtual memory because page tables are not changed
when an interrupt occurs. Instead what many (all?) operating systems
do is keep kernel memory mapped in a reserved part of virtual memory:
Linux is a "high half" operating system, where the high half of
virtual memory is reserved for kernel use. Note that the kernel pages
can in principle only be accessed from ring 0 (kernel).

To change the address of the user code, we can use the GNU [[https://man7.org/linux/man-pages/man1/ld.1.html][ld]] linker,
which has options to control the virtual address where code and data
segments are loaded. Choosing a memory range which is not
currently unused e.g above =0x5000000=, we can build userspace programs
with this =makefile= rule:
#+BEGIN_SRC makefile
.PHONY: user

# Compile user programs in src/bin
user: user/hello

user/% : src/bin/%.rs makefile
	cargo rustc --release --bin $* -- \
		-C linker-flavor=ld \
		-C link-args="-Ttext-segment=5000000 -Trodata-segment=5100000" \
		-C relocation-model=static
	mkdir -p user
	cp target/x86_64-blog_os/release/$* user/
#+END_SRC

which will build the =hello= executable and copy it into a =user/=
directory. The =main.rs= code can be changed to point to this new location:
#+BEGIN_SRC rust
process::new_user_thread(include_bytes!("../user/hello"));
#+END_SRC

While we're at it, we can add another rule:
#+BEGIN_SRC makefile
run : user
	cargo run --bin blog_os
#+END_SRC
so running =make run= will build everything and run.

