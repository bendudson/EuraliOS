* Interrupts and processes

This begins after [[https://os.phil-opp.com/heap-allocation/][Phil-Opp's excellent post on heap allocation]]: We
have a kernel with basic terminal and keyboard I/O, and kernel memory
allocation from a fixed size heap.

** Accessing processor context

The x86-interrupt calling convention saves scratch registers, and passes a pointer
to the exception stack frame to the handler function. It was introduced in
[[https://github.com/rust-lang/rust/pull/39832][this PR]] which has some useful comparisons and links. 

In =interrupts.rs= :
#+BEGIN_SRC rust
#[derive(Debug)]
#[repr(packed)]
pub struct Context {
    // These are pushed in the handler function
    pub r15: usize,
    pub r14: usize,
    pub r13: usize,

    pub r12: usize,
    pub r11: usize,
    pub r10: usize,
    pub r9: usize,

    pub r8: usize,
    pub rbp: usize,
    pub rsi: usize,
    pub rdi: usize,

    pub rdx: usize,
    pub rcx: usize,
    pub rbx: usize,
    pub rax: usize,
    // Below is the exception stack frame pushed by the CPU on interrupt
    // Note: For some interrupts (e.g. Page fault), an error code is pushed here
    rip: usize,     // Instruction pointer
    cs: usize,      // Code segment
    rflags: usize,  // Processor flags
    rsp: usize,     // Stack pointer
    ss: usize,      // Stack segment
    // Here the CPU may push values to align the stack on a 16-byte boundary (for SSE)
}
#+END_SRC

We now define a function

#+BEGIN_SRC rust
#[naked]
pub extern "x86-interrupt" fn timer_handler_naked (
   _stack_frame: InterruptStackFrame) {
  unsafe {
  ...
  }
}
#+END_SRC
Here the =x86-interrupt= calling convention is specified to satisfy
the requirements of the IDT =set_handler_fn= method, but doesn't have
any effect because the function is =[naked]=.

Because naked functions are still somewhat experimental, we
need to enable this feature in =lib.rs=:
#+BEGIN_SRC rust
#![feature(naked_functions)]
#+END_SRC

While we're editing =lib.rs=, add another feature we'll need soon:
#+BEGIN_SRC rust
#![feature(asm_sym)]
#+END_SRC
which enables the =sym= operands in assembly blocks, used to take
the address of symbols.

Now we can fill in the =unsafe= block in the =timer_handler_naked=
function. In =interrupts.rs= import the =asm!= macro:
#+BEGIN_SRC rust
use core::arch::asm;
#+END_SRC
and then create an =asm!= block inside the unsafe scope of
=timer_handler_naked=:
#+BEGIN_SRC rust
  asm!(
      // Disable interrupts
      "cli",
      // Push registers
      "push rax",
      "push rbx",
      "push rcx",
      "push rdx",

      "push rdi",
      "push rsi",
      "push rbp",
      "push r8",

      "push r9",
      "push r10",
      "push r11",
      "push r12",

      "push r13",
      "push r14",
      "push r15",

      // First argument in rdi with C calling convention
      "mov rdi, rsp",
      // Call the hander function. Note that this might switch stack.
      "call {handler}",

      // Pop scratch registers
      "pop r15",
      "pop r14",
      "pop r13",

      "pop r12",
      "pop r11",
      "pop r10",
      "pop r9",

      "pop r8",
      "pop rbp",
      "pop rsi",
      "pop rdi",

      "pop rdx",
      "pop rcx",
      "pop rbx",
      "pop rax",
      // Enable interrupts
      "sti",
      // Interrupt return
      "iretq",
      // Note: Getting the handler pointer here using `sym` operand, because
      // an `in` operand would clobber a register that we need to save, and we
      // can't have two asm blocks
      handler = sym timer_handler,
      options(noreturn)
  );
#+END_SRC

The final part is to create the actual handler which will be
called:
#+BEGIN_SRC rust
extern "C" fn timer_handler(context: &mut Context) {
    print!("+");

    // Tell the PIC that the interrupt has been processed
    unsafe {
        PICS.lock()
            .notify_end_of_interrupt(InterruptIndex::Timer.as_u8());
    }
}
#+END_SRC
Note that the C calling convention here means some registers will
be pushed onto the stack again.
We then set the IDT entry to the new handler:
#+BEGIN_SRC rust
idt[InterruptIndex::Timer.as_usize()]
            .set_handler_fn(timer_handler_naked); // new
#+END_SRC

*** Testing

First check that this compiles and runs (=cargo run=). We can
then check that the values of the registers are saved and
restored correctly. In the new =timer_handler= function we can
print some registers, change change them, and then checking
that the change is seen in the interrupted code.

In =main.rs=, before the =hlt_loop()= call we can try this:
#+BEGIN_SRC rust
  // Set some registers
  unsafe {
    asm!("mov r11, 0x4242",
         "mov rdi, 0x22",
         "mov rcx, 0x93"
    );
  }

  // Wait for an interrupt
  unsafe {asm!("hlt");}

  // Get the register values
  let (r11, rdi, rcx): (i64, i64, i64);
  unsafe {asm!("nop",
               lateout("r11") r11,
               lateout("rdi") rdi,
               lateout("rcx") rcx);}
  println!("R11: 0x{:x} RDI: 0x{:x} RCX: 0x{:x}", r11, rdi, rcx);
#+END_SRC
which will need the =asm!= macro so put =use core::arch::asm;= near
the top of =main.rs=. When this runs we should see
=R11: 0x4242 RDI: 0x22 RCX: 0x93=, so the registers weren't modified by
the interrupt.

Now in =interrupt.rs= we can access and modify some registers, and check
that they are set correctly:
#+BEGIN_SRC rust
extern "C" fn timer_handler(context: &mut Context) {
    print!("<0x{:x}, 0x{:x}>", context.r11, context.rcx);
    context.r11 = context.rdi + 0x5321;
    context.rcx = 0xdeadbeef;

    // Tell the PIC that the interrupt has been processed
    unsafe {
        PICS.lock()
            .notify_end_of_interrupt(InterruptIndex::Timer.as_u8());
    }
}
#+END_SRC
So we now print the values of some registers, and modify the =r11= and =rcx=
registers. Running again we should see:
#+BEGIN_SRC
<0x4242, 0x93> R11: 0x5343 RDI: 0x22 RCX: 0xDEADBEEF
It did not crash!
<0x5343, 0xDEADBEEF><0x5343, 0xDEADBEEF>...
#+END_SRC
This shows that the timer handler can read and modify the process state,
which we'll need when we want to switch processes.

*** Test case

To turn this into a test case we can keep around, we need some way to test the
wrapper code while replacing the =timer_handler=.
Based on the [[https://github.com/vinc/moros/blob/trunk/src/sys/idt.rs#L123][MOROS]] code, turn the =timer_handler_naked= function into a macro:

#+BEGIN_SRC rust
  macro_rules! wrap {
      ($func: ident => $wrapper:ident) => {
          #[naked]
          pub extern "x86-interrupt" fn $wrapper (_stack_frame: InterruptStackFrame) {
              unsafe{
                ...
              }
          }
      };
  }
#+END_SRC
which can create the hander as before:
#+BEGIN_SRC rust
wrap!(timer_handler => timer_handler_naked);
#+END_SRC
Running (=cargo run=) should give the same result as before, but now we can
write tests for the macro by wrapping different functions.

We can make a standalone test like the =stack_overflow= test by making the =Context= struct
members public, exporting the =wrap= function (renamed to =interrupt_wrap=), and setting up a minimal
IDT in the test case. This is in =tests/interrupt_wrap.rs=.

** Kernel task switching

Pre-emptive multitasking with kernel threads, using the timer
interrupt to switch between threads.

There is a lot of confusing information online about interrupt
handling in x86.  Most of this confusion is due to the different
behaviour which has evolved over the last 40-some years: Real mode,
32-bit protected mode and 64-bit mode all work somewhat differently.
For 64-bit mode there is a good summary [[https://os.phil-opp.com/cpu-exceptions/][here]]. 

There is sometimes a distinction between interrupts which result in a
change in privilege level (interrupt occurs when running user code in
ring 3), and interrupts which don't (interrupt occurs while running
kernel code).

In 64-bit mode interrupts can switch to known-good stacks which are
listed in the Interrupt Stack Table (IST), which has 7 entries. The
index into this table which should be used is specified in the
Interrupt Descriptor Table (IDT).



** Scheduling

   https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/6_CPU_Scheduling.html

Now that the kernel can switch between multiple threads,
we're ready to start isolating them from each other. We'll
also want to be able to load programs from memory and (eventually)
disk. This is what we'll tackle in the [[file:02-userspace.org][next section]].

